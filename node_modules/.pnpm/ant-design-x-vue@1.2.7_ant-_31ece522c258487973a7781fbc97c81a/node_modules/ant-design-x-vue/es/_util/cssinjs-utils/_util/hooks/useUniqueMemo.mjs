var i = Object.defineProperty;
var n = (a, t, e) => t in a ? i(a, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[t] = e;
var c = (a, t, e) => n(a, typeof t != "symbol" ? t + "" : t, e);
import { computed as r } from "vue";
const h = 1e3 * 60 * 10;
class p {
  constructor() {
    c(this, "map", /* @__PURE__ */ new Map());
    // Use WeakMap to avoid memory leak
    c(this, "objectIDMap", /* @__PURE__ */ new WeakMap());
    c(this, "nextID", 0);
    c(this, "lastAccessBeat", /* @__PURE__ */ new Map());
    // We will clean up the cache when reach the limit
    c(this, "accessBeat", 0);
  }
  set(t, e) {
    this.clear();
    const s = this.getCompositeKey(t);
    this.map.set(s, e), this.lastAccessBeat.set(s, Date.now());
  }
  get(t) {
    const e = this.getCompositeKey(t), s = this.map.get(e);
    return this.lastAccessBeat.set(e, Date.now()), this.accessBeat += 1, s;
  }
  getCompositeKey(t) {
    return t.map((s) => s && typeof s == "object" ? `obj_${this.getObjectID(s)}` : `${typeof s}_${s}`).join("|");
  }
  getObjectID(t) {
    if (this.objectIDMap.has(t))
      return this.objectIDMap.get(t);
    const e = this.nextID;
    return this.objectIDMap.set(t, e), this.nextID += 1, e;
  }
  clear() {
    if (this.accessBeat > 1e4) {
      const t = Date.now();
      this.lastAccessBeat.forEach((e, s) => {
        t - e > h && (this.map.delete(s), this.lastAccessBeat.delete(s));
      }), this.accessBeat = 0;
    }
  }
}
const o = new p();
function l(a, t) {
  return r(() => {
    const e = o.get(t);
    if (e)
      return e;
    const s = a();
    return o.set(t, s), s;
  });
}
export {
  l as default
};
