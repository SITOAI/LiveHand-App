import { inject as A, shallowRef as C, getCurrentInstance as T, defineComponent as g, watch as x, unref as d, provide as b } from "vue";
import P from "./Cache.mjs";
import { withInstall as v, arrayType as u, booleanType as l, someType as I, stringType as f, objectType as E } from "../type.mjs";
const J = "data-token-hash", h = "data-css-hash", V = "data-cache-path", i = "__cssinjs_instance__";
function s() {
  const e = Math.random().toString(12).slice(2);
  if (typeof document < "u" && document.head && document.body) {
    const o = document.body.querySelectorAll(`style[${h}]`) || [], {
      firstChild: n
    } = document.head;
    Array.from(o).forEach((t) => {
      t[i] = t[i] || e, t[i] === e && document.head.insertBefore(t, n);
    });
    const c = {};
    Array.from(document.querySelectorAll(`style[${h}]`)).forEach((t) => {
      var r;
      const a = t.getAttribute(h);
      c[a] ? t[i] === e && ((r = t.parentNode) == null || r.removeChild(t)) : c[a] = !0;
    });
  }
  return new P(e);
}
const p = Symbol("StyleContextKey"), N = () => {
  var n, c, t;
  const e = T();
  let o;
  if (e && e.appContext) {
    const a = (t = (c = (n = e.appContext) == null ? void 0 : n.config) == null ? void 0 : c.globalProperties) == null ? void 0 : t.__ANTDV_CSSINJS_CACHE__;
    a ? o = a : (o = s(), e.appContext.config.globalProperties && (e.appContext.config.globalProperties.__ANTDV_CSSINJS_CACHE__ = o));
  } else
    o = s();
  return o;
}, m = {
  cache: s(),
  defaultCache: !0,
  hashPriority: "low"
}, y = () => {
  const e = N();
  return A(p, C({
    ...m,
    cache: e
  }));
}, _ = (e) => {
  const o = y(), n = C({
    ...m,
    cache: s()
  });
  return x([() => d(e), o], () => {
    const c = {
      ...o.value
    }, t = d(e);
    Object.keys(t).forEach((r) => {
      const S = t[r];
      t[r] !== void 0 && (c[r] = S);
    });
    const {
      cache: a
    } = t;
    c.cache = c.cache || s(), c.defaultCache = !a && o.value.defaultCache, n.value = c;
  }, {
    immediate: !0
  }), b(p, n), n;
}, j = () => ({
  autoClear: l(),
  /** @private Test only. Not work in production. */
  mock: f(),
  /**
   * Only set when you need ssr to extract style on you own.
   * If not provided, it will auto create <style /> on the end of Provider in server side.
   */
  cache: E(),
  /** Tell children that this context is default generated context */
  defaultCache: l(),
  /** Use `:where` selector to reduce hashId css selector priority */
  hashPriority: f(),
  /** Tell cssinjs where to inject style in */
  container: I(),
  /** Component wil render inline  `<style />` for fallback in SSR. Not recommend. */
  ssrInline: l(),
  /** Transform css before inject in document. Please note that `transformers` do not support dynamic update */
  transformers: u(),
  /**
   * Linters to lint css before inject in document.
   * Styles will be linted after transforming.
   * Please note that `linters` do not support dynamic update.
   */
  linters: u()
}), w = v(/* @__PURE__ */ g({
  name: "AStyleProvider",
  inheritAttrs: !1,
  props: j(),
  setup(e, {
    slots: o
  }) {
    return _(e), () => {
      var n;
      return (n = o.default) == null ? void 0 : n.call(o);
    };
  }
})), q = {
  useStyleInject: y,
  useStyleProvider: _,
  StyleProvider: w
};
export {
  V as ATTR_CACHE_PATH,
  h as ATTR_MARK,
  J as ATTR_TOKEN,
  i as CSS_IN_JS_INSTANCE,
  w as StyleProvider,
  s as createCache,
  q as default,
  j as styleProviderProps,
  y as useStyleInject,
  _ as useStyleProvider
};
