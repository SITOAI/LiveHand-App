import { u as M } from "../_util/cssinjs/hooks/useCacheToken.tsx2.mjs";
import "../_util/cssinjs/StyleContext.mjs";
import X from "../_util/cssinjs/theme/createTheme.mjs";
import "../_util/warning.mjs";
import "../_util/cssinjs/theme/ThemeCache.mjs";
import { computed as e, unref as v } from "vue";
import "../_util/cssinjs/transformers/legacyLogicalProperties.mjs";
import { theme as l } from "ant-design-vue";
import { ignore as g, unitless as x } from "./patch-antd.mjs";
import L from "ant-design-vue/es/theme/util/alias.js";
import S from "../version/version.mjs";
const D = X(l.defaultAlgorithm), y = {
  screenXS: !0,
  screenXSMin: !0,
  screenXSMax: !0,
  screenSM: !0,
  screenSMMin: !0,
  screenSMMax: !0,
  screenMD: !0,
  screenMDMin: !0,
  screenMDMax: !0,
  screenLG: !0,
  screenLGMin: !0,
  screenLGMax: !0,
  screenXL: !0,
  screenXLMin: !0,
  screenXLMax: !0,
  screenXXL: !0,
  screenXXLMin: !0
}, d = (s, c, u) => {
  const n = u.getDerivativeToken(s), { override: h, ...t } = c;
  let r = {
    ...n,
    override: h
  };
  return r = L(r), t && Object.entries(t).forEach(([a, m]) => {
    const { theme: o, ...i } = m;
    let k = i;
    o && (k = d(
      {
        ...r,
        ...i
      },
      {
        override: i
      },
      o
    )), r[a] = k;
  }), r;
};
function I() {
  const { token: s, hashId: c, theme: u } = l.useToken(), n = e(() => ({
    token: s.value,
    hashed: c.value,
    theme: u.value
  })), {
    // @ts-expect-error
    override: h,
    // @ts-expect-error
    cssVar: t
  } = v(n), r = e(() => n.value.token), a = e(() => n.value.hashed), m = e(() => n.value.theme ?? D), o = M(
    // @ts-expect-error
    e(() => m.value),
    e(() => [l.defaultSeed, r.value]),
    e(() => ({
      salt: `${S}-${a.value || ""}`,
      override: h,
      getComputedToken: d,
      cssVar: t && {
        prefix: t.prefix,
        key: t.key,
        unitless: x,
        ignore: g,
        preserve: y
      }
    }))
  ), [
    i,
    // token
    k,
    // hashId
    // @ts-expect-error
    p
  ] = v(o), f = e(() => o.value[0]), T = e(() => a.value ? o.value[1] : "");
  return [m, p, T, f, t];
}
function q() {
  const [s, c, u] = I();
  return { theme: s, token: c, hashId: u };
}
export {
  q as default,
  d as getComputedToken,
  I as useInternalToken
};
