import { ref as F, computed as $ } from "vue";
import I from "./useSyncState.mjs";
import { useEventCallback as T } from "../_util/hooks/use-event-callback.mjs";
function W(i) {
  return Array.isArray(i) ? i : [i];
}
function U(i) {
  const {
    defaultMessages: q,
    agent: b,
    requestFallback: d,
    requestPlaceholder: f,
    parser: v,
    transformMessage: R,
    transformStream: A,
    resolveAbortController: h
  } = i, w = F(0), _ = $(() => (q || []).map((s, t) => ({
    id: `default_${t}`,
    status: "local",
    ...s
  }))), [m, g] = I(_.value, () => {
  }), M = (s, t) => {
    const o = {
      id: `msg_${w.value}`,
      message: s,
      status: t
    };
    return w.value += 1, o;
  }, x = $(() => {
    const s = [];
    return m.value.forEach((t) => {
      const o = v ? v(t.message) : t.message, u = W(o);
      u.forEach((l, p) => {
        let e = t.id;
        u.length > 1 && (e = `${e}_${p}`), s.push({
          id: e,
          message: l,
          status: t.status
        });
      });
    }), s;
  }), E = (s) => s.filter((t) => t.status !== "loading" && t.status !== "error").map((t) => t.message), S = () => E(m.value), k = (s) => typeof R == "function" ? R(s) : s.currentMessage;
  return {
    onRequest: T((s) => {
      if (!b)
        throw new Error(
          "The agent parameter is required when using the onRequest method in an agent generated by useXAgent."
        );
      let t = null, o, u = {};
      if (typeof s == "object" && (s != null && s.message)) {
        const { message: e, ...r } = s;
        o = e, u = r;
      } else
        o = s;
      g((e) => {
        let r = [...e, M(o, "local")];
        if (f) {
          let a;
          typeof f == "function" ? a = f(o, {
            messages: E(r)
          }) : a = f;
          const n = M(a, "loading");
          t = n.id, r = [...r, n];
        }
        return r;
      });
      let l = null;
      const p = (e, r) => {
        let a = m.value.find((n) => n.id === l);
        return a ? g((n) => n.map((c) => {
          if (c.id === l) {
            const y = k({
              originMessage: c.message,
              currentMessage: e,
              status: r
            });
            return {
              ...c,
              message: y,
              status: r
            };
          }
          return c;
        })) : (k({ currentMessage: e, status: r }), a = M(e, r), g((n) => [...n.filter((y) => y.id !== t), a]), l = a.id), a;
      };
      b.request(
        {
          message: o,
          messages: S(),
          ...u
        },
        {
          onUpdate: (e) => {
            p(e, "loading");
          },
          onSuccess: (e) => {
            p(e, "success");
          },
          onError: async (e) => {
            if (d) {
              let r;
              typeof d == "function" ? r = await d(o, {
                error: e,
                messages: S()
              }) : r = d, g((a) => [
                ...a.filter((n) => n.id !== t && n.id !== l),
                M(r, "error")
              ]);
            } else
              g((r) => r.filter((a) => a.id !== t && a.id !== l));
          },
          onStream: (e) => {
            h == null || h(e);
          }
        },
        A
      );
    }),
    messages: m,
    parsedMessages: x,
    setMessages: g
  };
}
export {
  U as default
};
