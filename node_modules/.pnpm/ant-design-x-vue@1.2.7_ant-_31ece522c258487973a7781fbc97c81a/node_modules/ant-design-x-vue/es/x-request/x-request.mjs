import y from "../x-stream/x-stream.mjs";
import R from "./x-fetch.mjs";
const s = class s {
  constructor(t) {
    this.create = async (h, e, o) => {
      var i, u;
      const n = new AbortController(), r = {
        method: "POST",
        body: JSON.stringify({
          model: this.model,
          ...h
        }),
        headers: this.defaultHeaders,
        signal: n.signal
      };
      (i = e == null ? void 0 : e.onStream) == null || i.call(e, n);
      try {
        const d = await R(this.baseURL, {
          fetch: this.customOptions.fetch,
          ...r
        });
        if (o) {
          await this.customResponseHandler(d, e, o);
          return;
        }
        const p = d.headers.get("content-type") || "";
        switch (p.split(";")[0].trim()) {
          /** SSE */
          case "text/event-stream":
            await this.sseResponseHandler(d, e);
            break;
          /** JSON */
          case "application/json":
            await this.jsonResponseHandler(d, e);
            break;
          default:
            throw new Error(`The response content-type: ${p} is not support!`);
        }
      } catch (d) {
        const p = d instanceof Error ? d : new Error("Unknown error!");
        throw (u = e == null ? void 0 : e.onError) == null || u.call(e, p), p;
      }
    }, this.customResponseHandler = async (h, e, o) => {
      var r, i;
      const n = [];
      for await (const u of y({
        readableStream: h.body,
        transformStream: o
      }))
        n.push(u), (r = e == null ? void 0 : e.onUpdate) == null || r.call(e, u);
      (i = e == null ? void 0 : e.onSuccess) == null || i.call(e, n);
    }, this.sseResponseHandler = async (h, e) => {
      var n, r;
      const o = [];
      for await (const i of y({
        readableStream: h.body
      }))
        o.push(i), (n = e == null ? void 0 : e.onUpdate) == null || n.call(e, i);
      (r = e == null ? void 0 : e.onSuccess) == null || r.call(e, o);
    }, this.jsonResponseHandler = async (h, e) => {
      var n, r;
      const o = await h.json();
      (n = e == null ? void 0 : e.onUpdate) == null || n.call(e, o), (r = e == null ? void 0 : e.onSuccess) == null || r.call(e, [o]);
    };
    const { baseURL: f, model: U, dangerouslyApiKey: g, ...w } = t;
    this.baseURL = t.baseURL, this.model = t.model, this.defaultHeaders = {
      "Content-Type": "application/json",
      ...t.dangerouslyApiKey && {
        Authorization: t.dangerouslyApiKey
      }
    }, this.customOptions = w;
  }
  static init(t) {
    if (!t.baseURL || typeof t.baseURL != "string")
      throw new Error("The baseURL is not valid!");
    const f = t.fetch || t.baseURL;
    return s.instanceBuffer.has(f) || s.instanceBuffer.set(f, new s(t)), s.instanceBuffer.get(f);
  }
};
s.instanceBuffer = /* @__PURE__ */ new Map();
let m = s;
const T = m.init;
export {
  T as default
};
