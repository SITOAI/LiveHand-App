const l = `

`, h = `
`, c = ":", u = (e) => (e ?? "").trim() !== "";
function m() {
  let e = "";
  return new TransformStream({
    transform(t, o) {
      e += t;
      const r = e.split(l);
      r.slice(0, -1).forEach((n) => {
        u(n) && o.enqueue(n);
      }), e = r[r.length - 1];
    },
    flush(t) {
      u(e) && t.enqueue(e);
    }
  });
}
function d() {
  return new TransformStream({
    transform(e, t) {
      const r = e.split(h).reduce((n, s) => {
        const a = s.indexOf(c);
        if (a === -1)
          throw new Error(
            `The key-value separator "${c}" is not found in the sse line chunk!`
          );
        const i = s.slice(0, a);
        if (!u(i)) return n;
        const f = s.slice(a + 1);
        return { ...n, [i]: f };
      }, {});
      Object.keys(r).length !== 0 && t.enqueue(r);
    }
  });
}
function p(e) {
  const { readableStream: t, transformStream: o } = e;
  if (!(t instanceof ReadableStream))
    throw new Error("The options.readableStream must be an instance of ReadableStream.");
  const r = new TextDecoderStream(), n = o ? (
    /**
     * Uint8Array binary -> string -> Output
     */
    t.pipeThrough(r).pipeThrough(o)
  ) : (
    /**
     * Uint8Array binary -> string -> SSE part string -> Default Output {@link SSEOutput}
     */
    t.pipeThrough(r).pipeThrough(m()).pipeThrough(d())
  );
  return n[Symbol.asyncIterator] = async function* () {
    const s = this.getReader();
    for (; ; ) {
      const { done: a, value: i } = await s.read();
      if (a) break;
      i && (yield i);
    }
  }, n;
}
export {
  p as default
};
