import b from "../_util/hooks/useMergedState.mjs";
import { computed as a, toValue as C, ref as u, watchEffect as E, onWatcherCleanup as P } from "vue";
let c;
!c && typeof window < "u" && (c = window.SpeechRecognition || window.webkitSpeechRecognition);
function x(h, w) {
  const m = h, i = a(() => {
    const e = C(w);
    return typeof e == "object" ? {
      controlledRecording: e.recording,
      onControlledRecordingChange: e.onRecordingChange,
      speechInControlled: typeof e.recording == "boolean"
    } : {
      controlledRecording: void 0,
      onControlledRecordingChange: void 0,
      speechInControlled: !1
    };
  }), R = a(() => i.value.controlledRecording), n = i.value.onControlledRecordingChange, S = i.value.speechInControlled, r = u(null);
  E(() => {
    if (typeof navigator < "u" && "permissions" in navigator) {
      let e = null;
      navigator.permissions.query({ name: "microphone" }).then((t) => {
        r.value = t.state, t.onchange = function() {
          r.value = this.state;
        }, e = t;
      }), P(() => {
        e && (e.onchange = null);
      });
    }
  });
  const f = a(() => c && r.value !== "denied"), o = u(null), [l, d] = b(!1, {
    value: R
  }), s = u(!1), y = () => {
    if (f.value && !o.value) {
      const e = new c();
      e.onstart = () => {
        d(!0);
      }, e.onend = () => {
        d(!1);
      }, e.onresult = (t) => {
        var p, v, g;
        if (!s.value) {
          const I = (g = (v = (p = t.results) == null ? void 0 : p[0]) == null ? void 0 : v[0]) == null ? void 0 : g.transcript;
          m(I);
        }
        s.value = !1;
      }, o.value = e;
    }
  };
  return { speechPermission: f, triggerSpeech: (e) => {
    e && !l.value || (s.value = e, S ? n == null || n(!l.value) : (y(), o.value && (l.value ? (o.value.stop(), n == null || n(!1)) : (o.value.start(), n == null || n(!0)))));
  }, recording: l };
}
export {
  x as default
};
